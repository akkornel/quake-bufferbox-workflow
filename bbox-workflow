#!/usr/bin/perl -w

use strict;
use warnings;

use Cwd;
use FindBin qw($RealScript);
use Fcntl qw(:flock);
use IPC::Open3;
use Symbol qw(gensym);


# First, let's set our "constants".  These are settings that aren't likely to
# change much (that's why they're in code, not in a config file).

# $TIMEOUT1 is how long we should wait, in minutes, for an "RTAComplete.txt"
# file to appear.
# We set this to 5 days.
# 5 (days) * 24 (hours) * 60 (minutes)
my $TIMEOUT1 = 7200;

# $RUNCOMMAND is the command we will run.
my @RUNCOMMAND = (qw(
bcl2fastq -l WARNING -o Data/Intensities/BaseCalls -p 9 -d 2 --no-lane-splitting
));

# Next, let's make a big list of global variables.  These all initially start
# out as undefined, and are filled in as we go along.

# $SEARCHFOLDER is the path to the directory that we look in when we are doing a
# "scan" operation.  In other words, $SEARCHDIR is where all the run folders
# live.
my $SEARCHFOLDER = undef;

# $RUNFOLDER is the path to the run folder.  Initially it contains the output
# from the instrument (the instrument copies it directly), and later on it
# will contain output from the analysis program, plus our logs.
my $RUNFOLDER = undef;

# $LOCKPATH is the path to the "workflow-lock.txt" file.  This file should
# only exist while a copy of bbox-workflow is running.
my $LOCKPATH = undef;

# $LOCKHANDLE is a File Handle pointing to $LOCKPATH
my $LOCKHANDLE = undef;

# $LOGPATH is the path to the "workflow-log.txt" file.
my $LOGPATH = undef;

# $LOGHANDLE is a File Handle pointing to $LOGPATH
my $LOGHANDLE = undef;

# $LOG contains messages that we haven't written to a log file yet.
# This is only useful when $LOGPATH is undefined.
my $LOG = "";

# $ACTION is what we are going to do.  It can be "scan", "run", or "deliver".
my $ACTION = undef;




# Now, let's do stuff!
# First, we're going to find out what our action is


# We should have at least one argument from the command line
if (scalar(@ARGV) < 1) {
	log_msg(<<"EOL");
Please specify an action to perform, like 'scan' or 'run'.
For example: $RealScript scan NextSeq
Or: $RealScript run NextSeq/160804-NS500126-123-BDGEJMGM
Or you can just say `$RealScript help` !
EOL
	exit 1;
}


# First, we need to see what action we're going to perform.
# Let's also set up code to run for each action.
$ACTION = shift @ARGV;
my %possible_actions;


$possible_actions{help} = sub {
	print "Help goes here!\n";
};

$possible_actions{scan} = sub {
	print "Not ready yet!\n";
};

$possible_actions{run} = sub {
	# Get the run folder from the command line
	if (scalar(@ARGV) < 1) {
		log_msg(<<"EOL");
When using the `run` action, please provide the path to the run folder.
For example: $RealScript run 160804-NS500126-0555-ABCDEFG
EOL
		exit 1;
	}
	my $candidate_runfolder = shift @ARGV;

	# Make sure the run folder is valid, and also set $SEARCHFOLDER
	$RUNFOLDER = validate_path($candidate_runfolder);
	if (!defined($RUNFOLDER)) {
		log_msg(<<"EOL");
The run folder you provided does not exist, is not a directory, or cannot be
read.  Please re-run your command with a valid folder path.
The path you provided is: $candidate_runfolder
EOL
		exit 1;
	}

	# Let's also set $SEARCHFOLDER, $LOGPATH, and $LOCKPATH
	$SEARCHFOLDER = Cwd::abs_path("$RUNFOLDER/../..");
	$LOGPATH = "$RUNFOLDER/workflow-log.txt";
	$LOCKPATH = "$RUNFOLDER/workflow-lock.txt";

	# Get a lock on our run folder
	lock_get() or exit(1);

	# Start logging to file
	log_open() or exit(1);

	# Wait for RTAComplete.txt to appear
	log_msg("Waiting for $RUNFOLDER/RTAComplete.txt to appear...\n");
	while ($TIMEOUT1 > 0) {
		# If the file exists, then stop the loop
		if (-r "$RUNFOLDER/RTAComplete.txt") {
			log_msg("File found!\n");
			last;
		}

		# If the file doesn't exist yet, wait a minute and try again
		$TIMEOUT1--;
		sleep(60);
	}
	# If we timed out, then exit.
	# TODO: Send Email
	if ($TIMEOUT1 == 0) {
		log_msg("Gave up waiting for $RUNFOLDER/RTAComplete.txt\n");
		return;
	}

	# Check to see if we have any Project directories
	my $basecalls_path = "$RUNFOLDER/Data/Intensities/BaseCalls";
	my $basecalls_handle;
	opendir($basecalls_handle, $basecalls_path) or do {
		log_msg(<<"EOF");
The BaseCalls directory does not exist, is not a directory, or cannot be read.
Please make sure you are running this command with a valid run folder!
The directory we are trying to open is: $basecalls_path
The error we are getting is: $!
EOF
		return;
	};
	while (readdir($basecalls_handle)) {
		# Find any directories whose name starts with "Project_"
		next unless $_ =~ m{\A        # Start of string
		                    (         # Start capturing match
		                    Project_  # "Project_"
		                    [a-z0-9]+ # One or more letters/numbers
		                    )         # End capture
		                    \z        # End of string
		                   }xims;

		# Rename the directory (this might recurse)
		log_msg(<<"EOF");
We found an existing Project directory: $1.
We are renaming this to $1.old.
(If that directory already exists, we'll add another ".old" to that one,
and so on, and so on, and ....)
EOF
		my $old_project_path = "$basecalls_path/$1";
		directory_rename($old_project_path);
	}

	# Get ready to run the analysis command
	log_msg("Running the analysis!\n");
	log_msg("Analysis command: " . join(' ', @RUNCOMMAND) . "\n");
	log_msg("Analysys command output:\n");
	log_msg("==========================================================\n");

	# Actually run the analysis command.
	# We send all output to the log directly.  We also make a file handle
	# for input, but then we immediately close it (we don't need it).
	my $input_handle;
	my $output_handle = gensym();
	my $analysis_buffer = '';
	chdir($RUNFOLDER);
	my $analysis_pid = open3($input_handle, $output_handle,
	                         0, @RUNCOMMAND);
	close($input_handle);
	while (read($output_handle, $analysis_buffer, 100)) {
		log_msg($analysis_buffer);
		$analysis_buffer = '';
	}
	waitpid($analysis_pid, 0);
	close($output_handle);

	# Clean up from the analysis command
	my $analysis_exit_code = $? >> 8;
	log_msg("==========================================================\n");
	log_msg("The analysis program exited with $analysis_exit_code\n");

	if ($analysis_exit_code == 0) {
		log_msg("That's good!\n")
	} else {
		log_msg("That's bad 8-(\n");
	}
};

# Now that we have our actions, let's execute the code
if (exists($possible_actions{$ACTION})) {
	# We are getting a subroutine reference from a Perl hash, dereferencing
	# it, and calling it.
	&{$possible_actions{$ACTION}};
}
else {
	log_msg(<<"EOL");
The action you specified, $ACTION, is not a known action.
You have three possible actions:
* scan: Scan a given directory for unprocessed work folders.
* run: Process (or re-process) a given work folder.
* deliver: Deliver the analysis results from a given work folder.
EOL
}

# That's it!  Let's exit
log_close();
lock_release();
exit 0;


#
# Logging and Locking Subroutines Go Here
# 


# Open our log file
sub log_open {
	# If our log file exists, then rename it by appending ".old".
	if (-r $LOGPATH) {
		log_rename($LOGPATH);
	}

	# Try opening our log file
	open($LOGHANDLE, '>', $LOGPATH) or do {
		log_msg(<<"EOL");
We are having trouble opening the log file.
The file we tried to create is: $LOGPATH
The error we got is: $!
EOL
		return 0;
	};

	# Put a header into the log file.
	# Also, if we have anything in our holding variable, output it.
	my $start_time = localtime(time());
	$LOG = <<"EOL";
This is the log of the bbox-workflow program!
This log file was started on: $start_time
If you need help, please email research-computing-support\@stanford.edu
$LOG
EOL
	print $LOGHANDLE $LOG;
	$LOG = '';

	# The log is ready to go!
	return 1;
}

# Rename a log file, by appending .old
# We make this a separate subroutine because we might recurse.
sub log_rename {
	my ($file) = @_;
	if (-r "$file.old") {
		log_rename("$file.old");
	}
	rename($file, "$file.old");
	return 1;
}

# Close the log
sub log_close {
	return unless defined($LOGHANDLE);
	my $end_time = localtime(time());
	print $LOGHANDLE <<"EOL";
The time is now $end_time.
Logging complete!
EOL

	close($LOGHANDLE);
	undef $LOGHANDLE;
	return 1;
}
	
# Log stuff
sub log_msg {
	my ($message) = @_;

	# First, print the log entry to standard output
	print $message;

	# Next, if the log file is open, output it there.
	# If the log file isn't open, then write to our holding variable.
	if (defined($LOGHANDLE)) {
		print $LOGHANDLE $message;
	} else {
		$LOG .= $message;
	}
}

# Create and lock our lock file
sub lock_get {
	# We already have $LOCKPATH set globally, so we'll use that.

	# First, open the lock file, in append mode.
	# We open in append mode because we don't want to change anything
	# immediately.  We'll wait for the lock first.
	open ($LOCKHANDLE, '>>', $LOCKPATH) or do {
		log_msg(<<"EOL");
We have just tried to create/open the following file:
$LOCKPATH
However, we got this error: $!
This should not happen.  Please contact Support!
EOL
		return 0;
	};

	# Actually take the lock.  If already locked, fail immediately.
	flock($LOCKHANDLE, LOCK_EX | LOCK_NB) or do {
		log_msg(<<"EOL");
It appears that the run folder you specified is already being actively worked
on by another instance of the workflow program.  You should wait for that other
instance to complete.  To see what it's doing, you can look at the log file,
which should be here: $LOGPATH
EOL
		return 0;
	};

	# We are locked!  Write in our process ID, and return.
	truncate($LOCKHANDLE, 0);
	print $LOCKHANDLE "$$\n";
	log_msg("Lock file $LOCKPATH locked.\n");
	return 1;
}

# Release our lock
sub lock_release {
	# We already have everything set globally
	return unless defined($LOCKHANDLE);
	unlink($LOCKPATH);
	flock($LOCKHANDLE, LOCK_UN);
	close($LOCKHANDLE);
	undef $LOCKHANDLE;
	return 1;
}


#
# Other Subroutines Go Here
# 


# Make sure a path is valid
sub validate_path {
	my ($path) = @_;

	if (   (-r $path)
	    && (-x $path)
	    && (-d $path)
	) {
		$path = Cwd::abs_path($path);
		return $path;
	} else {
		return undef;
	}
}

# Append .old to a directory
sub directory_rename {
	my ($path) = @_;
	my $new_name = "$path.old";
	if (-r $new_name) {
		directory_rename($new_name);
	}
	rename($path, $new_name);
}
