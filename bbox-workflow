#!/usr/bin/perl -w

use strict;
use warnings;

use Cwd;
use FindBin qw($RealScript);
use Fcntl qw(:flock);


# First, let's make a big list of global variables.  These all initially start
# out as undefined, and are filled in as we go along.

# $SEARCHFOLDER is the path to the directory that we look in when we are doing a
# "scan" operation.  In other words, $SEARCHDIR is where all the run folders
# live.
my $SEARCHFOLDER = undef;

# $RUNFOLDER is the path to the run folder.  Initially it contains the output
# from the instrument (the instrument copies it directly), and later on it
# will contain output from the analysis program, plus our logs.
my $RUNFOLDER = undef;

# $LOCKPATH is the path to the "workflow-lock.txt" file.  This file should
# only exist while a copy of bbox-workflow is running.
my $LOCKPATH = undef;

# $LOCKHANDLE is a File Handle pointing to $LOCKPATH
my $LOCKHANDLE = undef;

# $LOGPATH is the path to the "workflow-log.txt" file.
my $LOGPATH = undef;

# $LOGHANDLE is a File Handle pointing to $LOGPATH
my $LOGHANDLE = undef;

# $LOG contains messages that we haven't written to a log file yet.
# This is only useful when $LOGPATH is undefined.
my $LOG = "";

# $ACTION is what we are going to do.  It can be "scan", "run", or "deliver".
my $ACTION = undef;




# Now, let's do stuff!
# First, we're going to find out what our action is


# We should have at least one argument from the command line
if (scalar(@ARGV) < 1) {
	log_msg(<<"EOL");
Please specify an action to perform, like 'scan' or 'run'.
For example: $RealScript scan NextSeq
Or: $RealScript run NextSeq/160804-NS500126-123-BDGEJMGM
Or you can just say `$RealScript help` !
EOL
	exit 1;
}


# First, we need to see what action we're going to perform.
# Let's also set up code to run for each action.
$ACTION = shift @ARGV;
my %possible_actions;


$possible_actions{help} = sub {
	print "Help goes here!\n";
};

$possible_actions{scan} = sub {
	print "Not ready yet!\n";
};

$possible_actions{run} = sub {
	# Get the run folder from the command line
	if (scalar(@ARGV) < 1) {
		log_msg(<<"EOL");
When using the `run` action, please provide the path to the run folder.
For example: $RealScript run 160804-NS500126-0555-ABCDEFG
EOL
		exit 1;
	}
	my $candidate_runfolder = shift @ARGV;

	# Make sure the run folder is valid, and also set $SEARCHFOLDER
	$RUNFOLDER = validate_path($candidate_runfolder);
	if (!defined($RUNFOLDER)) {
		log_msg(<<"EOL");
The run folder you provided does not exist, is not a directory, or cannot be
read.  Please re-run your command with a valid folder path.
The path you provided is: $candidate_runfolder
EOL
		exit 1;
	}

	# Let's also set $SEARCHFOLDER, $LOGPATH, and $LOCKPATH
	$SEARCHFOLDER = Cwd::abs_path("$RUNFOLDER/../..");
	$LOGPATH = "$RUNFOLDER/workflow-log.txt";
	$LOCKPATH = "$RUNFOLDER/workflow-lock.txt";

	# Get a lock on our run folder
	get_lock($RUNFOLDER) or exit(1); {
EOL
	};

	# Start logging to file
};

# Now that we have our actions, let's execute the code
if (exists($possible_actions{$ACTION})) {
	# We are getting a subroutine reference from a Perl hash, dereferencing
	# it, and calling it.
	&{$possible_actions{$ACTION}};
}
else {
	log_msg(<<"EOL");
The action you specified, $ACTION, is not a known action.
You have three possible actions:
* scan: Scan a given directory for unprocessed work folders.
* run: Process (or re-process) a given work folder.
* deliver: Deliver the analysis results from a given work folder.
EOL
}

# That's it!  Let's exit
log_close();
exit 0;


#
# Logging and Locking Subroutines Go Here
# 


# Open our log file
sub log_open {
	# If our log file exists, then rename it by appending ".old".
	if (-r $LOGPATH) {
		log_rename($LOGPATH);
	}

	# Try opening our log file
	open($LOGHANDLE, '>', $LOGPATH) or {
		log_msg(<<"EOL");
We are having trouble opening the log file.
The file we tried to create is: $LOGPATH
The error we got is: $!
EOL
		return 0;
	}

	# Put a header into the log file.
	# Also, if we have anything in our holding variable, output it.
	my $start_time = localtime(time());
	$LOG = <<"EOL";
This is the log of the bbox-workflow program!
This log file was started on: $start_time
If you need help, please email research-computing-support@stanford.edu
$LOG
EOL
	print $LOGHANDLE $LOG;
	$LOG = '';

	# The log is ready to go!
	return 1;
}

# Rename a log file, by appending .old
# We make this a separate subroutine because we might recurse.
sub log_rename {
	my ($file) = @_;
	if (-r "$file.old") {
		log_rename("$file.old");
	}
	rename($file, "$file.old");
	return 1;
}

# Close the log
sub log_close {
	return unless defined($LOGHANDLE);
	my $end_time = localtime(time());
	print $LOGFILE <<"EOL";
The time is now $end_time.
Logging complete!
EOL

	close($LOGHANDLE);
	undef $LOGHANDLE;
	return 1;
}
	
# Log stuff
sub log_msg {
	my ($message) = @_;

	# First, print the log entry to standard output
	print $message, "\n";

	# Next, if the log file is open, output it there.
	# If the log file isn't open, then write to our holding variable.
	if (defined($LOGHANDLE)) {
		print $LOGHANDLE $message;
	} else {
		$LOG .= $message;
	}
}

# Create and lock our lock file
sub get_lock {
	# We already have $LOCKPATH set globally, so we'll use that.

	# First, open the lock file, in append mode.
	# We open in append mode because we don't want to change anything
	# immediately.  We'll wait for the lock first.
	open ($LOCKHANDLE, '>>', $LOCKPATH) or {
		log_msg(<<"EOL");
We have just tried to create/open the following file:
$LOCKPATH
However, we got this error: $!
This should not happen.  Please contact Support!
EOL
		return 0;
	};

	# Actually take the lock.  If already locked, fail immediately.
	flock($LOCKHANDLE, LOCK_EX | LOCK_NB) or {
		log_msg(<<"EOL");
It appears that the run folder you specified is already being actively worked
on by another instance of the workflow program.  You should wait for that other
instance to complete.  To see what it's doing, you can look at the log file,
which should be here: $LOGPATH
EOL
		return 0;
	};

	# We are locked!  Write in our process ID, and return.
	truncate($LOCKHANDLE, 0);
	print $LOCKHANDLE "$$\n";
	log_msg("Lock file $LOCKATH locked.\n");
	return 1;
}

# Release our lock
sub free_lock {
	# We already have everything set globally
	unlink($LOCKPATH);
	flock($LOCKHANDLE, LOCK_UN);
	close($LOCKHANDLE);
	undef $LOCKHANDLE;
	return 1;
}


#
# Other Subroutines Go Here
# 


# Make sure a path is valid
sub validate_path {
	my ($path) = @_;

	if (   (-r $path)
	    && (-x $path)
	    && (-d $path)
	) {
		$path = Cwd::abs_path($path);
		return $path;
	} else {
		return undef;
	}
}
